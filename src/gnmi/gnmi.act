import logging
import net
import base64
import grpc.grpc as grpc
import gnmi.proto as proto


actor Client(cap: net.TCPConnectCap, target: str, on_connect: action(Client) -> None, on_error: action(Client, str) -> None, insecure = False, log_handler: ?logging.Handler, tls_verify: bool = True, basic_creds: ?(str, str) = None):

    logh = logging.Handler("gnmi.Client")
    if log_handler is not None:
        logh.set_handler(log_handler)
    logger = logging.Logger(logh)

    def _on_connect(channel: grpc.Channel):
        on_connect(self)
    def _on_error(channel: grpc.Channel, error: str):
        on_error(self, error)

    creds = None if insecure else grpc.TlsChannelCredentials()

    additional_headers: dict[str, str] = {}
    if basic_creds is not None:
        username, password = basic_creds
        #creds_str = f'{username}:{password}'
        #creds_enc = creds_str.encode()
        #creds_b64: str = base64.encode(creds_enc).decode()
        #auth_str: str = 'Basic ' + creds_b64
        additional_headers['username'] = username
        additional_headers['password'] = password

    channel = grpc.Channel(cap, target, [], creds, None, _on_connect, _on_error, logh, tls_verify)

    def capabilities():
        def _on_response(channel: grpc.Channel, response: bytes) -> None:
            print(response)

        channel.unary_unary('/gnmi.gNMI/Capabilities', b'', _on_response, additional_headers=additional_headers)

    def get():
        def _on_response(channel: grpc.Channel, response: bytes) -> None:
            print(response)

        channel.unary_unary('/gnmi.gNMI/Get', b'', _on_response, additional_headers=additional_headers)

    def set():
        def _on_response(channel: grpc.Channel, response: bytes) -> None:
            print(response)

        channel.unary_unary('/gnmi.gNMI/Set', b'', _on_response, additional_headers=additional_headers)

    def subscribe(prefix: proto.Path, paths: list[proto.Path], mode: int, stream_mode: int, sample_interval):
        def _on_response(channel: grpc.Channel, response: bytes) -> None:
            print(response)

        allow_aggregation = False
        qos = 0
        encoding = proto.PROTO
        updates_only = False
        subscriptions: list[proto.Subscription] = []
        use_models: list[proto.ModelData] = []

        for path in paths:
            subscriptions.append(proto.Subscription(path, mode, sample_interval, False, sample_interval))

        request = proto.SubscribeRequest(proto.SubscriptionList(prefix, subscriptions, qos, mode, allow_aggregation, use_models, encoding, updates_only))
        payload: bytes = request.pack()
        channel.stream_stream('/gnmi.gNMI/Subscribe', [request.pack()], _on_response, additional_headers=additional_headers)


actor main(env):

    logh = logging.Handler("gnmi.main")
    logh.add_sink(logging.ConsoleSink())
    logh.set_output_level(logging.DEBUG)

    target = env.argv[1]
    insecure = False
    if len(env.argv) > 2:
        insecure = bool(env.argv[2])

    basic_creds = None
    if len(env.argv) > 4:
        username = env.argv[3]
        password = env.argv[4]
        basic_creds = (username, password)

    def on_connect(c: Client):
        print("Client connected", target)
        #c.get()
        #c.set()
        #c.capabilities()
        c.subscribe(proto.Path([proto.PathElem('openconfig-interfaces:interfaces', []), proto.PathElem('interface', []), proto.PathElem('state', [])]), [proto.Path([proto.PathElem('counters', []), proto.PathElem('in-pkts', [])]), proto.Path([proto.PathElem('counters', []), proto.PathElem('out-pkts', [])])], proto.STREAM, proto.SAMPLE, 5000000000)
    def on_error(c: Client, e: str):
        print("Error:", e)

    client = Client(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), target, on_connect, on_error, insecure=insecure, log_handler=logh, tls_verify=False, basic_creds=basic_creds)

    #prefix: /openconfig-interfaces:interfaces/interface/state
    #paths:
    #  - counters/in-pkts
    #  - counters/in-errors
    #  - counters/out-pkts
    #  - counters/out-errors
    #mode: STREAM
    #stream-mode: SAMPLE
    #sample-interval: 5s
