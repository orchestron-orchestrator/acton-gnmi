import json
#Encodings
JSON = 0
BYTES = 1
PROTO = 2
ASCII = 3
JSON_IETF = 4

# Subscription mode
TARGET_DEFINED = 0
ON_CHANGE = 1
SAMPLE = 2

# SubscriptionList mode
STREAM = 0
ONCE = 1
POLL = 2

class Any:
    type_url: str
    value: bytes

    def __init__(self, type_url: str, val: bytes):
        self.type_url = type_url
        self.value = val

    def __str__(self):
        return f'Any({self.type_url}, {self.value})'
    

class PathElem:
    name: str
    keys: list[(str, str)]

    def __init__(self, name: str, keys: list[(str, str)]):
        self.name = name
        self.keys = keys

    def __str__(self):
        formatted_keys = ''
        for pair in self.keys:
            key, val = pair
            formatted_keys += f'[{key}={val}]'
        return f'/{self.name}{formatted_keys}'

class Path:
    elems: list[PathElem]
    origin: str
    target: str

    def __init__(self, elems: list[PathElem], origin: str = '', target: str = ''):
        self.elems = elems
        self.origin = origin
        self.target = target

    def __str__(self):
        xpath = ''
        for elem in self.elems:
            xpath += str(elem)

        return f'Path({xpath}, origin={self.origin}, target={self.target})'

class ModelData:
    name: str
    organization: str
    version: str

    def __init__(self, name: str, organization: str, version: str):
        self.name = name
        self.organization = organization
        self.version = version

def pack_CapabilityRequest(p: CapabilityRequest) -> bytes:
    return b''

class CapabilityRequest:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_CapabilityRequest(self)

def pack_CapabilityResponse(p: CapabilityResponse) -> bytes:
    return b''

class CapabilityResponse:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_CapabilityResponse(self)

def pack_GetRequest(p: GetRequest) -> bytes:
    return b''

class GetRequest:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_GetRequest(self)

def pack_GetResponse(p: GetResponse) -> bytes:
    return b''

class GetResponse:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_GetResponse(self)

def pack_SetRequest(p: SetRequest) -> bytes:
    return b''

class SetRequest:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_SetRequest(self)

def pack_SetResponse(p: SetResponse) -> bytes:
    return b''

class SetResponse:
    def __init__(self):
        pass

    def pack(self) -> bytes:
        return pack_SetResponse(self)

def pack_SubscribeRequest(p: SubscribeRequest) -> bytes:
    NotImplemented

class Subscription:
    path: Path
    mode: int
    sample_interval: u64
    suppress_redundant: bool
    heartbeat_interval: u64

    def __init__(self, path: Path, mode: int, sample_interval: u64, suppress_redundant: bool, heartbeat_interval: u64):
        self.path = path
        self.mode = mode
        self.sample_interval = sample_interval
        self.suppress_redundant = suppress_redundant
        self.heartbeat_interval = heartbeat_interval
        
class SubscriptionList:
    prefix: Path
    subscriptions: list[Subscription]
    qos: u32
    mode: int
    allow_aggregation: bool
    use_models: list[ModelData]
    encoding: int
    updates_only: bool

    def __init__(self, prefix: Path, subscriptions: list[Subscription], qos: u32, mode: int, allow_aggregation: bool, use_models: list[ModelData], encoding: int, updates_only: bool):
        self.prefix = prefix
        self.subscriptions = subscriptions
        self.qos = qos
        self.mode = mode
        self.allow_aggregation = allow_aggregation
        self.use_models = use_models
        self.encoding = encoding
        self.updates_only = updates_only

class SubscribeRequest:
    # without a SubscriptionList, assume a poll request
    subscribe: ?SubscriptionList

    def __init__(self, subscribe: ?SubscriptionList):
        self.subscribe = subscribe

    def pack(self) -> bytes:
        return pack_SubscribeRequest(self)

VALUE__NOT_SET = 0,
VALUE_STRING_VAL = 1,
VALUE_INT_VAL = 2,
VALUE_UINT_VAL = 3,
VALUE_BOOL_VAL = 4,
VALUE_BYTES_VAL = 5,
VALUE_FLOAT_VAL = 6,
VALUE_DOUBLE_VAL = 14,
VALUE_DECIMAL_VAL = 7,
VALUE_LEAFLIST_VAL = 8,
VALUE_ANY_VAL = 9,
VALUE_JSON_VAL = 10,
VALUE_JSON_IETF_VAL = 11,
VALUE_ASCII_VAL = 12,
VALUE_PROTO_BYTES = 13

class TypedValue:
    #value: value

    #def __init__(self, value_value: value):
        #pass
        #self.value_type = value_type
        #self.value = value_value

    def __str__(self):
        #return f'TypedValue({self.value})'
        return f'TypedValue()'

class NotSetValue(TypedValue):
     def __init__(self):
         pass

     def __str__(self):
         return f'NotSetValue()'

class StringValue(TypedValue):
    value: str

    def __init__(self, val: str):
        self.value = val

    def __str__(self):
        return f'StringValue(\'{self.value}\')'

class IntValue(TypedValue):
    value: i64

    def __init__(self, val: i64):
        self.value = val

    def __str__(self):
        return f'IntValue({self.value})'

class UIntValue(TypedValue):
    value: u64

    def __init__(self, val: u64):
        self.value = val

    def __str__(self):
        return f'UintValue({self.value})'

class BoolValue(TypedValue):
    value: bool

    def __init__(self, val: bool):
        self.value = val

    def __str__(self):
        return f'BoolValue({self.value})'

class BytesValue(TypedValue):
    value: bytes

    def __init__(self, val: bytes):
        self.value = val

    def __str__(self):
        return f'BytesValue({self.value})'

class DoubleValue(TypedValue):
    value: float

    def __init__(self, val: float):
        self.value = val

    def __str__(self):
        return f'DoubleValue({self.value})'

VALUE_LEAFLIST_VAL = 8,
class LeafListValue(TypedValue):
    value: list[TypedValue]

    def __init__(self, val: list[TypedValue]):
        self.value = val

    def __str__(self):
        return f'LeafListValue({self.value})'

VALUE_ANY_VAL = 9,
class AnyValue(TypedValue):
    value: Any

    def __init__(self, val: Any):
        self.value = val

    def __str__(self):
        return f'AnyValue({self.value})'

VALUE_JSON_VAL = 10,
class JsonValue(TypedValue):
    value: dict[str, value]

    def __init__(self, val: dict[str, value]):
        self.value = val

    def __str__(self):
        return f'JsonValue({self.value})'

VALUE_JSON_IETF_VAL = 11,
class JsonIetfValue(TypedValue):
    value: dict[str, value]

    def __init__(self, val: dict[str, value]):
        self.value = val

    def __str__(self):
        return f'JsonIetfValue({self.value})'

VALUE_ASCII_VAL = 12,
class AsciiValue(TypedValue):
    value: str

    def __init__(self, val: str):
        self.value = val

    def __str__(self):
        return f'AsciiValue({self.value})'

VALUE_PROTO_BYTES = 13
class ProtoBytesValue(TypedValue):
    value: bytes

    def __init__(self, val: bytes):
        self.value = val

    def __str__(self):
        return f'ProtoBytesValue({self.value})'

class Update:
    path: Path
    val: TypedValue
    duplicates: u32

    def __init__(self, path: Path, val: TypedValue, duplicates: u32):
        self.path = path
        self.val = val
        self.duplicates = duplicates

    def __str__(self):
        return f'Update({self.path}, {self.val}, {self.duplicates})'

class Notification:
    timestamp: i64
    prefix: Path
    update: list[Update]
    delete: list[Path]
    atomic: bool

    def __init__(self, timestamp: i64, prefix: Path, update: list[Update], delete: list[Path], atomic: bool):
        self.timestamp = timestamp
        self.prefix = prefix
        self.update = update
        self.delete = delete
        self.atomic = atomic

    def __str__(self):
        updates_str = '['
        last = len(self.update) - 1
        for i, update in enumerate(self.update):
            updates_str += str(update)
            if i != last:
                updates_str += ', '
        updates_str += ']'

        return f'Notification({self.timestamp}, {self.prefix}, {updates_str}, {self.delete}, {self.atomic})'

def pack_SubscribeResponse(p: SubscribeResponse) -> bytes:
    return b''

def unpack_SubscribeResponse(b: bytes) -> SubscribeResponse:
    NotImplemented

class SubscribeResponse:
    response_case: int
    update: ?Notification
    sync_response: bool

    def __init__(self, response_case: int, update: ?Notification, sync_response: bool):
        self.response_case = response_case
        self.update = update
        self.sync_response = sync_response

    def __str__(self):
        return f'SubscribeResponse({self.response_case}, {self.update}, {self.sync_response})'

    def pack(self) -> bytes:
        return pack_SubscribeResponse(self)

